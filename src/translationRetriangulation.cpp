/* 
 * Copyright 2020 Philipp Mayer - philmay1992@gmail.com
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "translationRetriangulation.h"

void TranslationRetriangulation::buildPolygonsSideChange(){
	Triangle *t, *tTest, *oldTriangle;
	Vertex *v;
	TEdge *e, *oldEdge, *edgeToRemove;
	double areaOld, areaNew;

	// Find the polygon in opposite direction and remove the corresponding triangles

	// First of all we have to find the triangle in the correct direction of the
	// surrounding polygon
	tTest = new Triangle(prevV, nextV, newV);
	areaNew = (*tTest).signedArea();
	delete tTest;

	// We simple check one triangle and take the other one if it is not the right
	// one
	t = (*prevOldE).getT0();
	v = (*t).getOtherVertex(prevOldE);
	tTest = new Triangle(prevV, nextV, v);
	areaOld = (*tTest).signedArea();
	delete tTest;

	// Make sure to take the triangle in the right direction
	// TODO:
	// Maybe this condition is not complete
	if(signbit(areaOld) == signbit(areaNew) || (*v).getID() == (*nextV).getID())
		t = (*prevOldE).getT1();
	
	// Start building the polygon
	p0 = new Polygon(PolygonType::STARSHAPED);

	(*p0).addVertex(prevV);

	// Now we go along the surrounding polygon from prevOldE until we reach
	// nextOldE and remove all triangles and edges inside the surrounding polygon
	e = prevOldE;
	oldEdge = NULL;
	edgeToRemove = NULL;
	while((*e).getID() != (*nextOldE).getID()){
		(*p0).addEdge((*t).getEdgeNotContaining(original));

		// Go further to the next triangle
		e = (*t).getOtherEdgeContaining(original, e);
		(*p0).addVertex((*e).getOtherVertex(original));
		oldTriangle = t;
		t = (*e).getOtherTriangle(oldTriangle);

		// Remove the previous triangle
		delete oldTriangle;

		// Make sure to only remove the right edges
		// The first remove takes place in the second loop iteration and
		// is the edge of the first iteration, so it is delayed
		if(edgeToRemove != NULL)
			delete edgeToRemove;
		if(oldEdge != NULL)
			edgeToRemove = oldEdge;
		oldEdge = e;
	}

	// Remove the remaining edge
	if(edgeToRemove != NULL)
		delete edgeToRemove;

	// Close the polygon with a new edge
	e = new TEdge(prevV, nextV);
	(*p0).close(e);
	(*p0).setKernel(oldV);

	// Immediately add a new triangle to the translation
	new Triangle(e, prevOldE, nextOldE, prevV, nextV, original);
}

/*
	C ~ O ~ N ~ S ~ T ~ R ~ U ~ C ~ T ~ O ~ R ~ S
*/

/*
	Constructor:
	Generates a new Translation of type DEFAULT. Picks the moving vertex and its
	neighbors from the triangulations vertices list and initialize the translation path.

	@param 	Tr 		The triangulation the moving vertex lives in
	@param 	i 		The index of the moving vertex in the triangulation
	@param 	dX 		The x-component of the translation vector
	@param 	dY 		The y-component of the translation vector

	Note:
		Translations of other types can just be generated by the translation class itself.
*/
TranslationRetriangulation::TranslationRetriangulation(Triangulation *Tr, int i, double dX, double dY) :
	Translation(Tr, i, dX, dY), p0(NULL), p1(NULL), p2(NULL), p3(NULL){

	Triangle *t0, *t1;
	double areaOld, areaNew;

	t0 = new Triangle(prevV, nextV, oldV);
	t1 = new Triangle(prevV, nextV, newV);

	areaOld = (*t0).signedArea();
	areaNew = (*t1).signedArea();

	sideChange = signbit(areaOld) != signbit(areaNew);

	delete t0;
	delete t1;
}


/*
	O ~ T ~ H ~ E ~ R ~ S
*/

/*
	The function execute() processes a translation. First it calls checkSplit() for checking
	whether the translation can be executed directly or must be split. If the flag split is set,
	it calls one of the functions which split the translation into two translations
	(depending on the geometric case) and executes them, otherwise execute() executes the
	translation by successively working through the events in the event queue.

	@return 	Indicates whether the execution was rejected, aborted or fully processed

	Note:
		For more information on the splits see my Master Thesis
*/
enum Executed TranslationRetriangulation::execute(){

	// Find the polygons to retriangulate
	if(sideChange)
		buildPolygonsSideChange();

	// Move the vertex to its target position
	(*original).setPosition((*newV).getX(), (*newV).getY());

	return Executed::FULL;
}


/*
	D ~ E ~ S ~ T ~ R ~ U ~ C ~ T ~ O ~ R
*/

/*
	Destructor:
	Checks the surrounding polygon of the moved vertex and deletes all the remaining construction
	vertices and edges. It errors with exit code 6 if the surrounding polygon check fails. It also
	deletes the flip stack.
*/	
TranslationRetriangulation::~TranslationRetriangulation(){

}
